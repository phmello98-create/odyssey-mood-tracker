üîí RELAT√ìRIO COMPLETO DE SEGURAN√áA - ODYSSEY APP
Data: 14 de Dezembro de 2025  
App: Odyssey - Mood Tracker & Productivity  
Vers√£o Analisada: 1.0.0+1  
Status: üî¥ PR√â-PRODU√á√ÉO - NECESSITA CORRE√á√ïES CR√çTICAS
---
üìã SUM√ÅRIO EXECUTIVO
O Odyssey √© um aplicativo de produtividade e bem-estar que combina m√∫ltiplas funcionalidades: rastreamento de humor, gerenciamento de tarefas, h√°bitos, di√°rio pessoal, biblioteca de livros, time tracker, gamifica√ß√£o e aprendizado de idiomas.
Filosofia Identificada
Voc√™ desenvolveu o Odyssey com uma filosofia de privacidade local-first:
- ‚úÖ Todos os dados s√£o armazenados localmente primeiro (Hive)
- ‚úÖ Sincroniza√ß√£o na nuvem √© opcional
- ‚úÖ Modo Guest permite uso sem conta
- ‚úÖ Backup no Google Drive sob controle do usu√°rio
- ‚úÖ Sem analytics obrigat√≥rio
- ‚úÖ Voc√™ n√£o quer coletar, armazenar ou ver dados dos clientes
Esta √© uma excelente abordagem e est√° alinhada com as melhores pr√°ticas de privacidade! No entanto, existem gaps cr√≠ticos de implementa√ß√£o que precisam ser corrigidos para garantir que essa filosofia seja tecnicamente aplicada de forma segura.
---
üéØ CLASSIFICA√á√ÉO DE RISCO GERAL
| Categoria | Status | Prioridade |
|-----------|--------|------------|
| Dados Sens√≠veis de Sa√∫de | üî¥ CR√çTICO | URGENTE |
| Criptografia Local | üî¥ CR√çTICO | URGENTE |
| Backup Seguro | üî¥ CR√çTICO | URGENTE |
| Tokens e Credenciais | üü° M√âDIO | ALTA |
| Firestore Security Rules | üü¢ BOM | REVISAR |
| API Keys | üü° M√âDIO | M√âDIA |
| Conformidade LGPD/GDPR | üî¥ CR√çTICO | URGENTE |
| Notifica√ß√µes | üü° BAIXO | M√âDIA |
Veredicto: ‚ö†Ô∏è N√ÉO RECOMENDADO PARA PRODU√á√ÉO sem implementar as corre√ß√µes cr√≠ticas.
---
üö® VULNERABILIDADES CR√çTICAS (URGENTE)
1. üî¥ DADOS DE SA√öDE MENTAL SEM CRIPTOGRAFIA
Descri√ß√£o: Mood records e di√°rio pessoal cont√™m dados sens√≠veis de sa√∫de mental armazenados em texto puro no Hive.
Risco: 
- ALT√çSSIMO 
- Viola√ß√£o da LGPD Art. 11 (dados sens√≠veis)
- Viola√ß√£o do GDPR Art. 9 (special categories)
- Exposi√ß√£o em caso de acesso f√≠sico ao dispositivo
- Backup n√£o criptografado exp√µe dados
Dados Expostos:
// Hive boxes SEM encryption:
- mood_records (tipo 3) - Humor di√°rio, emo√ß√µes, notas
- diary_entries (tipo 20) - Di√°rio pessoal completo
- notes_v2 - Notas privadas
- tasks - Tarefas (podem conter info confidencial)
Solu√ß√£o Requerida:
// 1. Gerar encryption key por dispositivo
import 'package:hive/hive.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';
class SecureHiveManager {
  static const _storage = FlutterSecureStorage();
  static const _keyName = 'odyssey_hive_key';
  
  static Future<List<int>> getOrCreateEncryptionKey() async {
    // Tentar recuperar key existente
    String? keyString = await _storage.read(key: _keyName);
    
    if (keyString != null) {
      return base64Decode(keyString);
    }
    
    // Gerar nova key
    final key = Hive.generateSecureKey();
    await _storage.write(
      key: _keyName, 
      value: base64Encode(key),
    );
    
    return key;
  }
  
  static Future<HiveAesCipher> getCipher() async {
    final key = await getOrCreateEncryptionKey();
    return HiveAesCipher(key);
  }
}
// 2. Aplicar em boxes sens√≠veis
Future<void> initializeSecureHive() async {
  await Hive.initFlutter();
  
  final cipher = await SecureHiveManager.getCipher();
  
  // Boxes criptografados
  await Hive.openBox<MoodRecord>(
    'mood_records',
    encryptionCipher: cipher,
  );
  
  await Hive.openBox<DiaryEntry>(
    'diary_entries',
    encryptionCipher: cipher,
  );
  
  await Hive.openBox(
    'notes_v2',
    encryptionCipher: cipher,
  );
  
  // Outros boxes podem continuar sem encryption
  // (ex: configura√ß√µes, UI state)
}
Arquivos Afetados:
- lib/src/providers/app_initializer_provider.dart (linha ~50-100)
- Todos os repositories que usam esses boxes
A√ß√£o Requerida:
1. ‚úÖ Adicionar flutter_secure_storage: ^9.0.0 ao pubspec.yaml
2. ‚úÖ Implementar SecureHiveManager conforme c√≥digo acima
3. ‚úÖ Modificar inicializa√ß√£o do Hive no AppInitializer
4. ‚úÖ MIGRA√á√ÉO DE DADOS: Criar script para migrar dados existentes para boxes criptografados
5. ‚úÖ Testar em m√∫ltiplos dispositivos
---
2. üî¥ GOOGLE DRIVE BACKUP SEM CRIPTOGRAFIA
Descri√ß√£o: Backups completos do app s√£o salvos no Google Drive em JSON texto puro.
Arquivo: lib/src/utils/services/backup_service.dart
Risco:
- ALT√çSSIMO
- Todos os dados do app expostos em texto puro
- Backup inclui tokens e credenciais
- Google Drive pode ser comprometido
- Viola√ß√£o de privacidade massiva
Dados Expostos no Backup:
{
  version: 2,
  timestamp: ...,
  deviceInfo: {...},
  checksum: ...,
  data: {
    mood_records: [...],  // ‚Üê Texto puro!
    diary_entries: [...], // ‚Üê Texto puro!
    notes_v2: [...],      // ‚Üê Texto puro!
    tasks: [...],
    habits: [...],
    books_v3: [...],
    time_tracking_records: [...],
    gamification: {...},
    shared_prefs: {...}   // ‚Üê Pode conter tokens!
  }
}
Solu√ß√£o Requerida:
import 'package:encrypt/encrypt.dart' as encrypt;
import 'package:crypto/crypto.dart';
import 'dart:convert';
class EncryptedBackupService {
  // Gerar chave de criptografia derivada da senha do usu√°rio
  static List<int> _deriveKey(String password, List<int> salt) {
    final iterations = 100000;
    final keyLength = 32; // 256 bits
    
    // PBKDF2
    var hmac = Hmac(sha256, utf8.encode(password));
    var key = <int>[];
    
    for (var i = 1; key.length < keyLength; i++) {
      var block = hmac.convert([...salt, ...[(i >> 24) & 0xff, (i >> 16) & 0xff, (i >> 8) & 0xff, i & 0xff]]).bytes;
      var u = block;
      
      for (var j = 1; j < iterations; j++) {
        u = hmac.convert(u).bytes;
        for (var k = 0; k < block.length; k++) {
          block[k] ^= u[k];
        }
      }
      
      key.addAll(block);
    }
    
    return key.sublist(0, keyLength);
  }
  
  static Future<Map<String, dynamic>> createEncryptedBackup({
    required String password,
  }) async {
    // 1. Criar backup completo (como antes)
    final backupData = await _createCompleteBackup();
    final backupJson = jsonEncode(backupData);
    
    // 2. Gerar salt aleat√≥rio
    final salt = encrypt.SecureRandom(16).bytes;
    
    // 3. Derivar chave da senha
    final keyBytes = _deriveKey(password, salt);
    final key = encrypt.Key(Uint8List.fromList(keyBytes));
    
    // 4. Gerar IV aleat√≥rio
    final iv = encrypt.IV.fromSecureRandom(16);
    
    // 5. Criptografar
    final encrypter = encrypt.Encrypter(
      encrypt.AES(key, mode: encrypt.AESMode.cbc)
    );
    final encrypted = encrypter.encrypt(backupJson, iv: iv);
    
    // 6. Retornar backup criptografado
    return {
      'version': '3', // Nova vers√£o com encryption
      'encrypted': true,
      'salt': base64Encode(salt),
      'iv': base64Encode(iv.bytes),
      'data': encrypted.base64,
      'checksum': md5.convert(utf8.encode(backupJson)).toString(),
      'timestamp': DateTime.now().toIso8601String(),
    };
  }
  
  static Future<Map<String, dynamic>> decryptBackup({
    required Map<String, dynamic> encryptedBackup,
    required String password,
  }) async {
    // 1. Extrair metadados
    final salt = base64Decode(encryptedBackup['salt']);
    final iv = encrypt.IV(Uint8List.fromList(
      base64Decode(encryptedBackup['iv'])
    ));
    final encryptedData = encryptedBackup['data'];
    
    // 2. Derivar chave
    final keyBytes = _deriveKey(password, salt);
    final key = encrypt.Key(Uint8List.fromList(keyBytes));
    
    // 3. Descriptografar
    final encrypter = encrypt.Encrypter(
      encrypt.AES(key, mode: encrypt.AESMode.cbc)
    );
    
    try {
      final decrypted = encrypter.decrypt64(
        encryptedData,
        iv: iv,
      );
      
      final backupData = jsonDecode(decrypted);
      
      // 4. Validar checksum
      final computedChecksum = md5.convert(
        utf8.encode(decrypted)
      ).toString();
      
      if (computedChecksum != encryptedBackup['checksum']) {
        throw Exception('Backup corrupted: checksum mismatch');
      }
      
      return backupData;
      
    } catch (e) {
      throw Exception('Failed to decrypt: wrong password or corrupted data');
    }
  }
}
UI para Senha de Backup:
class BackupPasswordDialog extends StatefulWidget {
  final bool isCreatingBackup;
  
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(
        isCreatingBackup 
          ? 'Criar Senha de Backup' 
          : 'Senha do Backup'
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isCreatingBackup) ...[
            Text(
              'Escolha uma senha forte para proteger seu backup. '
              'IMPORTANTE: N√£o ser√° poss√≠vel recuperar o backup '
              'se voc√™ esquecer esta senha.',
              style: TextStyle(fontSize: 12),
            ),
            SizedBox(height: 16),
          ],
          TextField(
            obscureText: true,
            decoration: InputDecoration(
              labelText: 'Senha',
              suffixIcon: Icon(Icons.lock),
            ),
            onChanged: (value) => password = value,
          ),
          if (isCreatingBackup) ...[
            SizedBox(height: 12),
            TextField(
              obscureText: true,
              decoration: InputDecoration(
                labelText: 'Confirmar Senha',
              ),
              onChanged: (value) => confirmPassword = value,
            ),
          ],
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: () {
            if (isCreatingBackup && password != confirmPassword) {
              // Show error
              return;
            }
            Navigator.pop(context, password);
          },
          child: Text('Confirmar'),
        ),
      ],
    );
  }
}
A√ß√£o Requerida:
1. ‚úÖ Adicionar encrypt: ^5.0.3 ao pubspec.yaml
2. ‚úÖ Implementar EncryptedBackupService
3. ‚úÖ Criar UI para definir senha de backup
4. ‚úÖ Atualizar BackupService para usar encryption
5. ‚úÖ Adicionar op√ß√£o de backup local criptografado (sem Google Drive)
6. ‚úÖ IMPORTANTE: Informar usu√°rios que backups antigos precisam ser recriados
---
3. üî¥ CONFORMIDADE LGPD/GDPR INCOMPLETA
Descri√ß√£o: Faltam funcionalidades essenciais para conformidade com leis de prote√ß√£o de dados.
Problemas Identificados:
A) Falta de Consentimento Expl√≠cito para Dados Sens√≠veis
LGPD Art. 11: Dados de sa√∫de requerem consentimento espec√≠fico e destacado.
Solu√ß√£o:
class HealthDataConsentScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Seus Dados de Sa√∫de')),
      body: Padding(
        padding: EdgeInsets.all(24),
        child: Column(
          children: [
            Icon(Icons.health_and_safety, size: 64, color: Colors.red),
            SizedBox(height: 24),
            Text(
              'O Odyssey coleta dados sens√≠veis de sa√∫de mental',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 16),
            Text(
              'Ao usar as funcionalidades de registro de humor e di√°rio, '
              'voc√™ estar√° compartilhando informa√ß√µes sobre seu estado '
              'emocional e bem-estar mental. Esses dados s√£o considerados '
              'sens√≠veis pela LGPD e GDPR.',
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 24),
            _buildDataUsageCard(
              icon: Icons.phone_android,
              title: 'Armazenamento Local',
              description: 'Seus dados s√£o armazenados criptografados '
                          'no seu dispositivo.',
            ),
            _buildDataUsageCard(
              icon: Icons.cloud_off,
              title: 'Sincroniza√ß√£o Opcional',
              description: 'Voc√™ escolhe se quer sincronizar na nuvem. '
                          'Por padr√£o, tudo fica local.',
            ),
            _buildDataUsageCard(
              icon: Icons.visibility_off,
              title: 'Privacidade Total',
              description: 'N√£o vendemos, n√£o compartilhamos, n√£o '
                          'acessamos seus dados pessoais.',
            ),
            Spacer(),
            CheckboxListTile(
              value: consent,
              onChanged: (value) => setState(() => consent = value!),
              title: Text(
                'Eu entendo e consinto explicitamente com a coleta '
                'e processamento dos meus dados sens√≠veis de sa√∫de mental.',
                style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold),
              ),
            ),
            SizedBox(height: 16),
            ElevatedButton(
              onPressed: consent ? () => _saveConsent() : null,
              child: Text('Continuar'),
              style: ElevatedButton.styleFrom(
                minimumSize: Size(double.infinity, 50),
              ),
            ),
            TextButton(
              onPressed: () => _showPrivacyPolicy(),
              child: Text('Ler Pol√≠tica de Privacidade Completa'),
            ),
          ],
        ),
      ),
    );
  }
}
B) Falta de Exporta√ß√£o de Dados
LGPD Art. 18: Usu√°rio tem direito a portabilidade dos dados.
Solu√ß√£o:
class DataExportService {
  static Future<File> exportAllUserData() async {
    final user = await AuthRepository.currentUser;
    
    // 1. Coletar TODOS os dados
    final exportData = {
      'user_info': {
        'uid': user.uid,
        'email': user.email,
        'displayName': user.displayName,
        'created_at': user.createdAt?.toIso8601String(),
      },
      'mood_records': await _exportMoodRecords(),
      'diary_entries': await _exportDiary(),
      'tasks': await _exportTasks(),
      'habits': await _exportHabits(),
      'notes': await _exportNotes(),
      'books': await _exportBooks(),
      'time_tracking': await _exportTimeTracking(),
      'gamification': await _exportGamification(),
      'settings': await _exportSettings(),
      'export_metadata': {
        'date': DateTime.now().toIso8601String(),
        'version': '1.0.0',
        'format': 'JSON',
      },
    };
    
    // 2. Converter para JSON formatado
    final jsonString = JsonEncoder.withIndent('  ').convert(exportData);
    
    // 3. Salvar em arquivo
    final directory = await getApplicationDocumentsDirectory();
    final file = File('${directory.path}/odyssey_data_export_${DateTime.now().millisecondsSinceEpoch}.json');
    await file.writeAsString(jsonString);
    
    return file;
  }
  
  static Future<void> shareExport(File file) async {
    await Share.shareXFiles(
      [XFile(file.path)],
      subject: 'Meus Dados - Odyssey',
      text: 'Exporta√ß√£o completa dos meus dados do app Odyssey',
    );
  }
}
C) Falta de Dele√ß√£o Completa de Conta
LGPD Art. 18: Direito ao esquecimento.
Solu√ß√£o:
class AccountDeletionService {
  static Future<void> deleteAccountCompletely({
    required String userId,
    required String password, // Confirmar identidade
  }) async {
    // 1. Validar senha
    final isValid = await _validatePassword(password);
    if (!isValid) {
      throw Exception('Senha incorreta');
    }
    
    // 2. Deletar do Firestore (se existir)
    if (!user.isGuest) {
      await _deleteFirestoreData(userId);
      await _deleteStorageFiles(userId);
    }
    
    // 3. Deletar backups do Google Drive
    await _deleteGoogleDriveBackups();
    
    // 4. Deletar dados locais
    await _deleteAllHiveBoxes();
    await _deleteSharedPreferences();
    await _deleteSecureStorage();
    
    // 5. Deletar conta do Firebase Auth
    if (!user.isGuest) {
      await FirebaseAuth.instance.currentUser?.delete();
    }
    
    // 6. Log de auditoria (an√¥nimo)
    await _logAccountDeletion(userId: 'DELETED', timestamp: DateTime.now());
    
    // 7. Limpar cache e tempor√°rios
    await _clearAppCache();
  }
  
  static Future<void> _deleteFirestoreData(String userId) async {
    final batch = FirebaseFirestore.instance.batch();
    
    // Deletar cole√ß√µes
    final collections = [
      'moods', 'tasks', 'habits', 'notes', 'quotes',
      'books', 'timeTracking', 'diary', 'gamification',
    ];
    
    for (final collection in collections) {
      final docs = await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .collection(collection)
          .get();
          
      for (final doc in docs.docs) {
        batch.delete(doc.reference);
      }
    }
    
    // Deletar documento do usu√°rio
    batch.delete(
      FirebaseFirestore.instance.collection('users').doc(userId)
    );
    
    await batch.commit();
  }
}
UI para Dele√ß√£o:
class DeleteAccountScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Excluir Conta'),
        backgroundColor: Colors.red,
      ),
      body: Padding(
        padding: EdgeInsets.all(24),
        child: Column(
          children: [
            Icon(Icons.warning, size: 80, color: Colors.red),
            SizedBox(height: 24),
            Text(
              'Aten√ß√£o: Esta a√ß√£o √© irrevers√≠vel',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Colors.red,
              ),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 16),
            Text(
              'Ao excluir sua conta, TODOS os seus dados ser√£o '
              'permanentemente deletados:',
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 24),
            _buildDeletionItem('Registros de humor'),
            _buildDeletionItem('Di√°rio pessoal'),
            _buildDeletionItem('Tarefas e h√°bitos'),
            _buildDeletionItem('Notas e anota√ß√µes'),
            _buildDeletionItem('Biblioteca de livros'),
            _buildDeletionItem('Dados de gamifica√ß√£o'),
            _buildDeletionItem('Backups na nuvem'),
            _buildDeletionItem('Conta e configura√ß√µes'),
            SizedBox(height: 24),
            Text(
              'Recomendamos fazer um backup antes de continuar.',
              style: TextStyle(fontStyle: FontStyle.italic),
              textAlign: TextAlign.center,
            ),
            Spacer(),
            ElevatedButton.icon(
              onPressed: () => _showBackupOption(),
              icon: Icon(Icons.download),
              label: Text('Fazer Backup Antes'),
              style: ElevatedButton.styleFrom(
                minimumSize: Size(double.infinity, 50),
              ),
            ),
            SizedBox(height: 12),
            OutlinedButton.icon(
              onPressed: () => _confirmDeletion(),
              icon: Icon(Icons.delete_forever),
              label: Text('Excluir Conta Permanentemente'),
              style: OutlinedButton.styleFrom(
                foregroundColor: Colors.red,
                minimumSize: Size(double.infinity, 50),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Future<void> _confirmDeletion() async {
    // Dialog de confirma√ß√£o final com senha
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Confirma√ß√£o Final'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Digite sua senha para confirmar:'),
            SizedBox(height: 16),
            TextField(
              obscureText: true,
              decoration: InputDecoration(labelText: 'Senha'),
              onChanged: (value) => password = value,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('Cancelar'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text('Confirmar Exclus√£o', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      await AccountDeletionService.deleteAccountCompletely(
        userId: user.uid,
        password: password,
      );
      // Navegar para tela de boas-vindas
    }
  }
}
A√ß√£o Requerida:
1. ‚úÖ Implementar tela de consentimento de dados de sa√∫de
2. ‚úÖ Adicionar exporta√ß√£o de dados no menu de configura√ß√µes
3. ‚úÖ Implementar dele√ß√£o completa de conta
4. ‚úÖ Criar pol√≠tica de privacidade detalhada
5. ‚úÖ Adicionar termos de uso
6. ‚úÖ Log de auditoria (an√¥nimo) para compliance
---
üü° VULNERABILIDADES DE PRIORIDADE ALTA
4. üü° TOKENS E CREDENCIAIS EM SHARED PREFERENCES
Descri√ß√£o: Tokens de autentica√ß√£o podem estar sendo armazenados em SharedPreferences (n√£o seguro).
Risco: M√âDIO-ALTO
- SharedPreferences n√£o √© criptografado
- Tokens podem ser extra√≠dos com root/jailbreak
- Sess√µes podem ser roubadas
Solu√ß√£o:
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
class SecureTokenStorage {
  static const _storage = FlutterSecureStorage(
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
    ),
    iOptions: IOSOptions(
      accessibility: KeychainAccessibility.first_unlock,
    ),
  );
  
  // Armazenar tokens
  static Future<void> saveAuthToken(String token) async {
    await _storage.write(key: 'auth_token', value: token);
  }
  
  static Future<String?> getAuthToken() async {
    return await _storage.read(key: 'auth_token');
  }
  
  static Future<void> deleteAuthToken() async {
    await _storage.delete(key: 'auth_token');
  }
  
  // Google Drive tokens
  static Future<void> saveGoogleDriveToken(String token) async {
    await _storage.write(key: 'gdrive_token', value: token);
  }
  
  static Future<String?> getGoogleDriveToken() async {
    return await _storage.read(key: 'gdrive_token');
  }
  
  // FCM tokens
  static Future<void> saveFCMToken(String token) async {
    await _storage.write(key: 'fcm_token', value: token);
  }
  
  // Limpar tudo no logout
  static Future<void> clearAll() async {
    await _storage.deleteAll();
  }
}
Arquivos a Modificar:
- lib/src/features/auth/data/firebase_auth_repository.dart
- lib/src/utils/services/backup_service.dart
- lib/src/features/auth/services/firebase_service.dart
---
5. üü° VALIDA√á√ÉO DE OWNERSHIP NO FIRESTORE
Descri√ß√£o: As Firestore Security Rules est√£o boas, mas podem ser aprimoradas.
Arquivo Atual: firestore.rules (linhas 31-39)
Melhorias Sugeridas:
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==========================================
    // HELPER FUNCTIONS
    // ==========================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isValidTimestamp(timestamp) {
      return timestamp is timestamp && 
             timestamp <= request.time + duration.value(1, 'd');
    }
    
    function isValidMoodRecord(data) {
      return data.keys().hasAll(['label', 'score', 'date']) &&
             data.score is int &&
             data.score >= 1 &&
             data.score <= 5 &&
             isValidTimestamp(data.date);
    }
    
    function isValidTask(data) {
      return data.keys().hasAll(['title', 'completed']) &&
             data.title is string &&
             data.title.size() > 0 &&
             data.title.size() <= 500;
    }
    
    function hasValidFields(data, requiredFields) {
      return data.keys().hasAll(requiredFields);
    }
    
    // Limitar tamanho de documentos
    function isSizeValid(data) {
      return request.resource.size() < 1048576; // 1 MB max
    }
    
    // Rate limiting b√°sico (protege contra spam)
    function notTooFrequent() {
      return !exists(/databases/$(database)/documents/users/$(request.auth.uid)/rate_limit/$(request.time.toMillis() / 1000))
             || resource.data.count < 100; // 100 requests por segundo
    }
    
    // ==========================================
    // REGRAS PADR√ÉO
    // ==========================================
    
    match /{document=**} {
      allow read, write: if false; // Deny all por padr√£o
    }
    
    // ==========================================
    // USERS COLLECTION
    // ==========================================
    
    match /users/{userId} {
      allow read: if isOwner(userId);
      
      allow create: if isOwner(userId) && 
                       isSizeValid(request.resource.data) &&
                       hasValidFields(request.resource.data, ['uid', 'createdAt']);
      
      allow update: if isOwner(userId) && 
                       isSizeValid(request.resource.data) &&
                       // N√£o permitir mudan√ßa de uid
                       request.resource.data.uid == resource.data.uid;
      
      allow delete: if isOwner(userId);
      
      // ==========================================
      // SUBCOLLECTIONS
      // ==========================================
      
      // Moods
      match /moods/{moodId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) && 
                         isValidMoodRecord(request.resource.data) &&
                         isSizeValid(request.resource.data);
        allow update: if isOwner(userId) && 
                         isValidMoodRecord(request.resource.data);
        allow delete: if isOwner(userId);
      }
      
      // Tasks
      match /tasks/{taskId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) && 
                         isValidTask(request.resource.data) &&
                         isSizeValid(request.resource.data);
        allow update: if isOwner(userId) && 
                         isValidTask(request.resource.data);
        allow delete: if isOwner(userId);
      }
      
      // Habits
      match /habits/{habitId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) && 
                         isSizeValid(request.resource.data) &&
                         hasValidFields(request.resource.data, ['name']);
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
      
      // Notes (dados sens√≠veis)
      match /notes/{noteId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId) && 
                        isSizeValid(request.resource.data);
      }
      
      // Diary (MUITO sens√≠vel)
      match /diary/{entryId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId) && 
                        isSizeValid(request.resource.data);
      }
      
      // Outras subcollections
      match /{subcollection}/{docId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId) && 
                        isSizeValid(request.resource.data);
      }
    }
    
    // ==========================================
    // APP CONFIG (READ-ONLY)
    // ==========================================
    
    match /app_config/{document} {
      allow read: if isAuthenticated();
      allow write: if false; // Apenas via Admin SDK
    }
    
    // ==========================================
    // GLOBAL QUOTES (READ-ONLY)
    // ==========================================
    
    match /global_quotes/{quoteId} {
      allow read: if isAuthenticated();
      allow write: if false; // Apenas via Admin SDK
    }
  }
}
A√ß√£o Requerida:
1. ‚úÖ Substituir firestore.rules pelo c√≥digo acima
2. ‚úÖ Publicar no Firebase Console
3. ‚úÖ Testar exaustivamente
4. ‚úÖ Monitorar rejections no Firebase Console
---
6. üü° IMPLEMENT FIREBASE APP CHECK
Descri√ß√£o: Proteger APIs do Firebase contra abuso e bots.
Solu√ß√£o:
# pubspec.yaml
dependencies:
  firebase_app_check: ^0.2.1+0
// lib/main.dart
import 'package:firebase_app_check/firebase_app_check.dart';
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  
  // ‚úÖ ADICIONAR: App Check
  await FirebaseAppCheck.instance.activate(
    // Use Play Integrity no Android
    androidProvider: AndroidProvider.playIntegrity,
    // Use DeviceCheck no iOS
    appleProvider: AppleProvider.deviceCheck,
    // Debug provider para desenvolvimento
    webProvider: ReCaptchaV3Provider('YOUR_RECAPTCHA_SITE_KEY'),
  );
  
  runApp(ProviderScope(child: MyApp()));
}
Firebase Console:
1. Ativar App Check no console
2. Configurar Play Integrity (Android)
3. Configurar DeviceCheck (iOS)
4. Aplicar enforcement em todas as APIs
---
üü¢ BOAS PR√ÅTICAS IDENTIFICADAS
Voc√™ j√° est√° fazendo v√°rias coisas certas:
‚úÖ Arquitetura Local-First
- Hive como armazenamento prim√°rio
- Sincroniza√ß√£o opcional
- Modo guest dispon√≠vel
‚úÖ Firestore Security Rules B√°sicas
- Ownership validation presente
- Deny-by-default approach
‚úÖ Modelos Imut√°veis com Freezed
- Type safety
- Facilita debugging
- Previne muta√ß√µes acidentais
‚úÖ Repository Pattern
- Abstra√ß√£o clara
- Test√°vel
- Separa√ß√£o de responsabilidades
‚úÖ Riverpod State Management
- Reativo
- Type-safe
- Garbage collection autom√°tico
---
üìù CHECKLIST DE IMPLEMENTA√á√ÉO
URGENTE (Fazer ANTES do lan√ßamento)
- [ ] Criptografar Hive boxes sens√≠veis
  - [ ] Implementar SecureHiveManager
  - [ ] Adicionar flutter_secure_storage
  - [ ] Migrar dados existentes
  - [ ] Testar em m√∫ltiplos dispositivos
  
- [ ] Criptografar backups do Google Drive
  - [ ] Implementar EncryptedBackupService
  - [ ] Adicionar encrypt package
  - [ ] Criar UI para senha de backup
  - [ ] Avisar usu√°rios sobre backups antigos
  
- [ ] Implementar consentimento LGPD/GDPR
  - [ ] Tela de consentimento de dados de sa√∫de
  - [ ] Pol√≠tica de privacidade detalhada
  - [ ] Termos de uso
  - [ ] Checkbox de aceite expl√≠cito
  
- [ ] Exporta√ß√£o de dados
  - [ ] Implementar DataExportService
  - [ ] Adicionar menu em configura√ß√µes
  - [ ] Formato JSON leg√≠vel
  - [ ] Compartilhamento via share sheet
  
- [ ] Dele√ß√£o completa de conta
  - [ ] Implementar AccountDeletionService
  - [ ] UI de confirma√ß√£o
  - [ ] Deletar Firestore
  - [ ] Deletar Storage
  - [ ] Deletar Google Drive backups
  - [ ] Deletar dados locais
  - [ ] Deletar Firebase Auth
  
- [ ] Migrar tokens para Secure Storage
  - [ ] Implementar SecureTokenStorage
  - [ ] Migrar auth tokens
  - [ ] Migrar Google Drive tokens
  - [ ] Migrar FCM tokens
ALTA PRIORIDADE
- [ ] Aprimorar Firestore Security Rules
  - [ ] Adicionar valida√ß√µes de campos
  - [ ] Limitar tamanho de documentos
  - [ ] Implementar rate limiting b√°sico
  - [ ] Publicar e testar
  
- [ ] Implementar Firebase App Check
  - [ ] Adicionar package
  - [ ] Configurar Play Integrity
  - [ ] Configurar DeviceCheck
  - [ ] Ativar enforcement
  
- [ ] Anonimizar Analytics
  - [ ] Desabilitar coleta de IP
  - [ ] Remover identifiers pessoais
  - [ ] Adicionar opt-out
  
- [ ] Revisar notifica√ß√µes
  - [ ] Op√ß√£o de notifica√ß√µes gen√©ricas
  - [ ] N√£o incluir dados sens√≠veis em payloads
  - [ ] Respeitar configura√ß√µes do SO
M√âDIA PRIORIDADE
- [ ] Versionamento de dados
  - [ ] Schema versions no Hive
  - [ ] Migrations autom√°ticas
  
- [ ] Logs de auditoria
  - [ ] Login/logout
  - [ ] Mudan√ßas de dados sens√≠veis
  - [ ] An√¥nimos (apenas timestamps e actions)
  
- [ ] Sanitiza√ß√£o de inputs
  - [ ] Validar todos os campos de texto
  - [ ] Limitar tamanhos
  - [ ] Prevenir XSS (se usar WebView)
  
- [ ] Deep links validation
  - [ ] Validar schemas
  - [ ] Sanitizar par√¢metros
---
üéØ RECOMENDA√á√ïES ADICIONAIS
1. Documenta√ß√£o de Privacidade
Criar documentos obrigat√≥rios:
Pol√≠tica de Privacidade (PRIVACY_POLICY.md):
 Pol√≠tica de Privacidade - Odyssey
√öltima atualiza√ß√£o: [DATA]
 1. Introdu√ß√£o
O Odyssey respeita sua privacidade. Este documento explica como coletamos, 
usamos e protegemos seus dados pessoais.
 2. Dados Coletados
- **Dados de conta**: Email, nome, foto de perfil (se usar Google Sign-In)
- **Dados de uso**: Registros de humor, tarefas, h√°bitos, notas, di√°rio
- **Dados t√©cnicos**: Tipo de dispositivo, vers√£o do app, idioma
 3. Como Usamos Seus Dados
- **Localmente primeiro**: Todos os dados s√£o armazenados no seu dispositivo
- **Sincroniza√ß√£o opcional**: Voc√™ escolhe se quer sincronizar na nuvem
- **Sem venda**: NUNCA vendemos seus dados
- **Sem compartilhamento**: N√£o compartilhamos com terceiros
- **Sem acesso**: N√£o acessamos seus dados pessoais
 4. Dados Sens√≠veis de Sa√∫de
O Odyssey coleta dados relacionados a sa√∫de mental (humor, bem-estar).
Esses dados s√£o considerados sens√≠veis pela LGPD e GDPR.
- **Criptografia**: Dados sens√≠veis s√£o criptografados no dispositivo
- **Consentimento**: Voc√™ deve consentir explicitamente
- **Controle total**: Voc√™ pode exportar ou deletar a qualquer momento
 5. Seus Direitos (LGPD/GDPR)
Voc√™ tem direito a:
- **Acesso**: Ver todos os seus dados
- **Exporta√ß√£o**: Baixar uma c√≥pia dos seus dados
- **Corre√ß√£o**: Corrigir dados incorretos
- **Exclus√£o**: Deletar sua conta permanentemente
- **Portabilidade**: Transferir seus dados
- **Revoga√ß√£o**: Revogar consentimentos
 6. Seguran√ßa
- Criptografia AES-256 para dados sens√≠veis
- Armazenamento local seguro (Hive)
- Backups criptografados
- Tokens em keychain/keystore
 7. Reten√ß√£o de Dados
- **Dados locais**: Mantidos at√© voc√™ deletar
- **Dados na nuvem**: Deletados quando voc√™ excluir a conta
- **Backups**: Sob seu controle no Google Drive
 8. Contato
Para exercer seus direitos ou d√∫vidas sobre privacidade:
Email: privacy@odysseyapp.com
Termos de Uso (TERMS_OF_SERVICE.md):
 Termos de Uso - Odyssey
 1. Aceita√ß√£o dos Termos
Ao usar o Odyssey, voc√™ concorda com estes termos.
 2. Uso do Servi√ßo
- Voc√™ √© respons√°vel pelo conte√∫do que cria
- N√£o use para atividades ilegais
- Mantenha suas credenciais seguras
 3. Dados e Privacidade
- Leia nossa Pol√≠tica de Privacidade
- Voc√™ mant√©m ownership dos seus dados
- Podemos processar dados conforme consentimento
 4. Responsabilidades
- O Odyssey n√£o substitui atendimento m√©dico/psicol√≥gico
- Em caso de crise, procure ajuda profissional
- N√£o nos responsabilizamos por perda de dados devido a falha de dispositivo
 5. Assinatura PRO
- Pagamento via Google Play/App Store
- Cancelamento dispon√≠vel a qualquer momento
- Sem reembolsos (conforme pol√≠ticas das stores)
 6. Modifica√ß√µes
Podemos atualizar estes termos. Notificaremos sobre mudan√ßas significativas.
 7. Encerramento
Voc√™ pode deletar sua conta a qualquer momento.
2. UI de Seguran√ßa
Adicionar se√ß√£o de Privacidade e Seguran√ßa em Configura√ß√µes:
class PrivacySecurityScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Privacidade e Seguran√ßa')),
      body: ListView(
        children: [
          // Informa√ß√µes gerais
          _buildInfoCard(
            icon: Icons.security,
            title: 'Seus Dados Est√£o Seguros',
            description: 'Todos os seus dados sens√≠veis s√£o criptografados '
                        'e armazenados com seguran√ßa no seu dispositivo.',
          ),
          
          Divider(),
          
          // Criptografia
          ListTile(
            leading: Icon(Icons.lock),
            title: Text('Criptografia'),
            subtitle: Text('AES-256 para dados sens√≠veis'),
            trailing: Chip(
              label: Text('ATIVADA'),
              backgroundColor: Colors.green,
            ),
          ),
          
          // Dados Sens√≠veis
          ListTile(
            leading: Icon(Icons.health_and_safety),
            title: Text('Dados de Sa√∫de Mental'),
            subtitle: Text('Humor, di√°rio e notas pessoais'),
            onTap: () => _showHealthDataInfo(),
          ),
          
          Divider(),
          
          // Sincroniza√ß√£o
          SwitchListTile(
            secondary: Icon(Icons.cloud_sync),
            title: Text('Sincroniza√ß√£o na Nuvem'),
            subtitle: Text(
              syncEnabled 
                ? 'Seus dados s√£o sincronizados com seguran√ßa' 
                : 'Dados armazenados apenas localmente'
            ),
            value: syncEnabled,
            onChanged: (value) => _toggleSync(value),
          ),
          
          // Backup
          ListTile(
            leading: Icon(Icons.backup),
            title: Text('Backup Criptografado'),
            subtitle: Text('Google Drive (opcional)'),
            trailing: Icon(Icons.chevron_right),
            onTap: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => BackupScreen()),
            ),
          ),
          
          Divider(),
          
          // Exportar dados
          ListTile(
            leading: Icon(Icons.download),
            title: Text('Exportar Meus Dados'),
            subtitle: Text('Download completo em JSON'),
            onTap: () => _exportData(),
          ),
          
          // Deletar conta
          ListTile(
            leading: Icon(Icons.delete_forever, color: Colors.red),
            title: Text('Excluir Minha Conta', style: TextStyle(color: Colors.red)),
            subtitle: Text('Apagar todos os dados permanentemente'),
            onTap: () => _navigateToDeleteAccount(),
          ),
          
          Divider(),
          
          // Documentos legais
          ListTile(
            leading: Icon(Icons.article),
            title: Text('Pol√≠tica de Privacidade'),
            trailing: Icon(Icons.open_in_new),
            onTap: () => _openPrivacyPolicy(),
          ),
          
          ListTile(
            leading: Icon(Icons.gavel),
            title: Text('Termos de Uso'),
            trailing: Icon(Icons.open_in_new),
            onTap: () => _openTermsOfService(),
          ),
          
          SizedBox(height: 24),
          
          // Informa√ß√µes de vers√£o
          Center(
            child: Column(
              children: [
                Text(
                  'Odyssey v1.0.0',
                  style: TextStyle(color: Colors.grey),
                ),
                SizedBox(height: 8),
                Text(
                  'Seus dados est√£o protegidos com criptografia AES-256',
                  style: TextStyle(color: Colors.grey, fontSize: 12),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
          
          SizedBox(height: 24),
        ],
      ),
    );
  }
}
3. Testing de Seguran√ßa
Criar testes automatizados:
// test/security_test.dart
import 'package:flutter_test/flutter_test.dart';
void main() {
  group('Security Tests', () {
    test('Hive encryption key should be generated', () async {
      final key = await SecureHiveManager.getOrCreateEncryptionKey();
      expect(key, isNotEmpty);
      expect(key.length, equals(32)); // 256 bits
    });
    
    test('Backup encryption should work', () async {
      final password = 'test_password_123';
      final originalData = {'test': 'data'};
      
      final encrypted = await EncryptedBackupService.createEncryptedBackup(
        data: originalData,
        password: password,
      );
      
      final decrypted = await EncryptedBackupService.decryptBackup(
        encryptedBackup: encrypted,
        password: password,
      );
      
      expect(decrypted, equals(originalData));
    });
    
    test('Wrong password should fail decryption', () async {
      final password = 'correct_password';
      final wrongPassword = 'wrong_password';
      final originalData = {'test': 'data'};
      
      final encrypted = await EncryptedBackupService.createEncryptedBackup(
        data: originalData,
        password: password,
      );
      
      expect(
        () => EncryptedBackupService.decryptBackup(
          encryptedBackup: encrypted,
          password: wrongPassword,
        ),
        throwsException,
      );
    });
    
    test('Tokens should be stored securely', () async {
      const testToken = 'test_auth_token_12345';
      
      await SecureTokenStorage.saveAuthToken(testToken);
      final retrieved = await SecureTokenStorage.getAuthToken();
      
      expect(retrieved, equals(testToken));
    });
  });
}
---
üìä ESTIMATIVA DE ESFOR√áO
| Tarefa | Prioridade | Tempo Estimado | Complexidade |
|--------|-----------|----------------|--------------|
| Criptografar Hive | CR√çTICO | 8-12h | M√©dia |
| Criptografar Backups | CR√çTICO | 6-8h | M√©dia |
| Consentimento LGPD | CR√çTICO | 4-6h | Baixa |
| Exporta√ß√£o de Dados | CR√çTICO | 6-8h | M√©dia |
| Dele√ß√£o de Conta | CR√çTICO | 8-10h | Alta |
| Secure Token Storage | ALTA | 4-6h | Baixa |
| Firestore Rules | ALTA | 3-4h | Baixa |
| Firebase App Check | ALTA | 2-3h | Baixa |
| Pol√≠tica de Privacidade | ALTA | 3-4h | Baixa |
| UI de Seguran√ßa | M√âDIA | 4-6h | Baixa |
| Testes de Seguran√ßa | M√âDIA | 6-8h | M√©dia |
TOTAL ESTIMADO: 54-75 horas (~2 semanas de trabalho focado)
---
‚úÖ CONCLUS√ÉO E PR√ìXIMOS PASSOS
Sua Filosofia Est√° Correta! ‚ú®
Voc√™ est√° no caminho certo ao n√£o querer coletar, armazenar ou acessar dados dos clientes. Essa √© a melhor abordagem de privacidade poss√≠vel: zero-knowledge architecture.
Mas Precisa Ser Implementada Corretamente
Os principais gaps s√£o:
1. Falta de criptografia nos dados sens√≠veis
2. Backups desprotegidos
3. Conformidade LGPD/GDPR incompleta
Priorize Estas 5 A√ß√µes
1. ‚úÖ Implementar criptografia do Hive (CR√çTICO)
2. ‚úÖ Criptografar backups (CR√çTICO)
3. ‚úÖ Adicionar consentimento expl√≠cito (CR√çTICO)
4. ‚úÖ Implementar exporta√ß√£o de dados (CR√çTICO)
5. ‚úÖ Implementar dele√ß√£o completa (CR√çTICO)
